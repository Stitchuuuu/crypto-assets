<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="apple-mobile-web-app-title" content="My Crypto">
	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
	<meta name="mobile-web-app-capable" content="yes">
	<meta name="mobile-web-app-title" content="My Crypto">
	<link rel="apple-touch-icon" sizes="180x180" href="/www/icons/touch-icon-iphone-180x180.png">
	<link rel="apple-touch-icon" sizes="167x167" href="/www/icons/touch-icon-ipad-167x167.png">
	<script src="https://unpkg.com/vue@next"></script>
	<script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
	<script src="https://unpkg.com/peerjs@1.3.1/dist/peerjs.min.js"></script>
	<script src="/utils.js"></script>
	<style>
		[v-cloak] { display: none; }
		body, #app, button, input[type=button], input[type=submit] {
			font-family: Avenir, Helvetica, Arial, sans-serif;
			-webkit-font-smoothing: antialiased;
			-moz-osx-font-smoothing: grayscale;
			background-color: #091044;
			color: #F6AC5E;
		}
		div, span, button, a, p, h1, h2, h3, h4, h5 {
			box-sizing: border-box;
		}
		a {
			color: #F6AC5E;
		}
		svg {
			fill: #F6AC5E;
		}
		button, a.button {
			outline: 0;
			border: 0;
			padding: 0.2em 0.5em;
			background-color: #F6AC5E;
			color: #091044;
			cursor: pointer;
			text-decoration: none;
		}
		body {
			margin: 0;
			padding: 0;
		}
	</style>
	<style>
		#app {
			height: 100vh;
			width: 100vw;
			padding: 20px;
		}
		.menu {
			margin-bottom: 30px;
			font-size: 1.5em;
		}
		.menu a {
			margin-right: 20px;
			text-decoration: none;
			border-bottom: 2px solid rgba(246, 172, 94, 0);
			transition: border-bottom-color 0.4s;
		}
		.menu a.active, .menu a:hover {
			border-bottom: 2px solid rgba(246, 172, 94, 1);
		}
		.content {
			padding-bottom: 30px;
		}
		@media only screen and (max-width: 600px) {
			.menu {
				width: 100%;
				overflow-x: auto;
				overflow-y: hidden;
				padding-bottom: 20px;
			}
		}
	</style>
	<style>
		.all-invests {
			display: flex;
			flex-direction: column;
			width: 640px;
		}
		.all-invests > div {
			display: flex;
		}
		.all-invests > div > div {
			margin-right: 10px;
			width: calc(100%/5);
			padding: 10px 10px;
		}
		.all-invests > div:nth-child(even) {
			background-color: rgba(255, 255, 255, 0.2);
		}
		.all-invests > div:nth-child(odd) {
			background-color: rgba(255, 255, 255, 0.1);
		}
		.all-invests > div > div:nth-child(1) {
			flex: 1;
			width: auto;
		}
		.all-invests > div > div:nth-child(2),
		.all-invests > div > div:nth-child(3),
		.all-invests > div > div:nth-child(4),
		.all-invests > div > div:nth-child(5) {
			width: 100px;
		}
		.all-invests .small {
			font-size: 0.7em;
		}
		.header {
			font-weight: bold;
		}
		.all-invests_total {
			margin-top: 20px;
			font-weight: bold;
		}
		button, a.button {
			font-size: 1.5em;
			transition: background-color 0.3s;
			margin-left: 2px;
			margin-right: 2px;
		}
		a.button:hover, button:hover {
			background-color:rgba(246, 172, 94, 0.8);
			cursor: pointer;
		}
		@media only screen and (max-width: 600px) {
			.all-invests {
				overflow-y: auto;
			}
			.content {
				overflow-y: auto;
			}
		}
	</style>
	<style>
		.notifications {
			position: fixed;
			z-index: 1000;
			top: 0;
			right: 0;
			padding-top: 20px;
			padding-right: 20px;
		}
		.notification {
			padding: 10px;
			padding-right: 40px;
			width: 400px;
			text-align: left;
			position: relative;
			margin-bottom: 10px;
			margin-top: 0;
		}
		.notification-close {
			right: 0;
			padding: 10px;
			top: 0;
			cursor: pointer;
			position: absolute;
		}
		.notification--success {
			background-color: #3F910C;
			color: #091044;
		}
		.notification--error {
			background-color: #451E10;
			color: white;
		}
		.notification-enter-active, .notification-leave-active {
			transition: all 0.5s;
		}
		.notification-enter-from, .notification-leave-to {
			opacity: 0;
		}
		.notification-enter-from {
			transform: translateY(-30px);
		}
		@media only screen and (max-width: 600px) {
			.notifications {
				left: 0;
				top: 0;
				padding: 20px;
			}
			.notification {
				width: auto;
			}
		}
	</style>
	<style>
		.sync button, .sync a.button {
			font-size: 16px;
		}
		.sync button:first-child {
			margin-left: 20px;
		}
		.sync-mean {
			margin-bottom: 10px;
			display: flex;
			align-items: center;
		}
		.sync-mean span {
			width: 120px;
		}
	</style>
</head>
<body>
	<div id="app" v-cloak>
		<div class="menu">
			<a href="#" :class="{'active': menuActive === 'main'}" @click="menuActive = 'main'">Résumé</a>
			<a href="#" :class="{'active': menuActive === 'invest'}" @click="menuActive = 'invest'">Investissement</a>
			<a href="#" :class="{'active': menuActive === 'settings'}" @click="menuActive = 'settings'">Paramètres</a>
			<a href="#" :class="{'active': menuActive === 'sync'}" @click="menuActive = 'sync'">Synchronisation</a>
		</div>
		<div class="content" :class="menuActive">
			<template v-if="menuActive === 'main'">
				<div class="all-invests">
					<div class="header">
						<div>Crypto</div>
						<div>Montant</div>
						<div>Montant €</div>
						<div>Gain</div>
						<div>Gain %</div>
					</div>
					<div v-for="invest in allInvestsBySymbol" :key="invest.symbol">
						<div>
							<div>{{ getName(invest) }}</div>
							<div class="small">{{ getQuoteLastUpdateDate(invest) }}</div>
						</div>
						<div>
							<div>{{ invest.value < 0.01 ? Number(invest.value).toFixed(5) : Number(invest.value).toFixed(2) }}</div>
							<div class="small">@ {{ getQuoteValue(invest) }} €</div>
						</div>
						<div>{{ Number(getValueInCurrency(invest)).toFixed(2) }} €</div>
						<div>{{ Number(getProfit(invest)).toFixed(2) }} €</div>
						<div>{{ invest.amount === 0 ? '' : Number(getProfitPercent(invest) * 100).toFixed(2) + '%' }}</div>
					</div>
					<div class="all-invests_total">
						<div>Total</div>
						<div>{{ Number(totalAmountInvests).toFixed(2) }} €</div>
						<div>{{ Number(totalValueInvests).toFixed(2) }} €</div>
						<div>{{ Number(totalProfit).toFixed(2) }} €</div>
						<div>{{ Number(totalProfitPercent * 100).toFixed(2) }} %</div>
					</div>
				</div>
			</template>
			<template v-else-if="menuActive === 'sync'">
				<div class="sync-mean">
					<span>Copier/Coller</span>
					<button @click="exportData($event, 'clipboard')">Exporter</button>
					<button @click="importData($event, 'clipboard')">Importer</button>
				</div>
				<div class="sync-mean">
					<span>Fichier</span>
					<input type="file" ref="file" accept="application/json" @change="importData($event, 'file')" style="visibility: hidden; position: absolute; top:0; left: 0;" />
					<a class="button" @click="exportData($event, 'file')">Exporter</a>
					<button @click="importData($event, 'file')" @drop.prevent="importData($event, 'file')" @dragover.prevent.stop="$event.dataTransfer.dropEffect = 'copy'">Importer</button>
				</div>
				<div class="sync-mean">
					<span>Clé (P2P)</span>
					<template v-if="!this.syncKey">
						<button @click="generateSyncKey">Créer nouvelle clé</button>
						<button @click="importData($event, 'synckey')">Importer clé</button>	
					</template>
					<template v-else>
						<button @click="exportData($event, 'synckey')">Copier clé</button>
						<button>Afficher clé</button>
						<button @click="syncKey = null">Supprimer clé</button>
					</template>
				</div>
			</template>
		</div>
		<div class="notifications">
			<transition-group name="notification" @leave="notificationLeave">
				<div v-for="notification in notifications" :key="notification.id" :class="'notification notification--' + notification.type">
					{{ notification.text }}
					<span class="notification-close" @click="notificationClose(notification)">✕</span>
				</div>
			</transition-group>
		</div>
	</div>
	<script>
	const axios = window.axios
	let peerClient = null
	let peerOtherClients = {}
	let app
	const _id = function() {
		return Date.now().toString(36) + '-' + Math.random().toString(36)
	}
	const $app = Vue.createApp({
		data: () => ({
			menuActive: 'sync',
			invests: [],
			symbols: {},
			quotes: {},
			timeoutRefreshQuotes: -1,
			notifications: [],
			syncKey: null,
			peerSubclientID: 1,
			peerClientInfo: {
				connecting: false,
				connected: false,
				timeoutReconnect: -1,
				intervalSearchKind: -1,
			},
		}),
		computed: {
			totalAmountInvests() {
				return this.invests.reduce((v, invest) => v + (invest.amount || 0), 0)
			},
			totalValueInvests() {
				return this.allInvestsBySymbol.reduce((v, invest) => v + this.getValueInCurrency(invest), 0)
			},
			totalProfit() {
				return this.totalValueInvests - this.totalAmountInvests
			},
			totalProfitPercent() {
				return this.totalProfit / this.totalValueInvests
			},
			allInvestsBySymbol() {
				const bySymbols = {}
				const symbols = this.symbols
				for (const invest of this.invests) {
					if (!bySymbols[invest.symbol]) bySymbols[invest.symbol] = { 
						amount: 0, 
						value: 0, 
						symbol: invest.symbol,
					}
					bySymbols[invest.symbol].amount += invest.amount || 0
					bySymbols[invest.symbol].value += invest.value || 0
				}
				return Object.values(bySymbols)
			},
			syncKeyWords() {
				if (!this.syncKey) return ''
				else return window.$utils.getWordsFromKey(this.syncKey)
			},
		},
		methods: {
			generateSyncKey() {
				this.syncKey = window.$utils.generateRandomKey()
			},
			notificationLeave(el) {
				el.style.marginTop = (-1 * el.offsetHeight - 10) + 'px'
			},
			notificationClose(n) {
				const index = this.notifications.findIndex(notif => notif.id === n.id)
				if (index >= 0) {
					this.notifications.splice(index, 1)
				}
			},
			notificationPush(type, text, timeout = 5000) {
				const n = {
					type,
					text,
					id: _id(),
				}
				this.notifications.push(n)
				if (timeout) {
					setTimeout(() => {
						this.notificationClose(n)
					}, timeout)
				}
			},
			exportData(e, type) {
				if (type === 'clipboard') {
					const data = JSON.stringify({
						invests: this.invests,
					})
					try {
						navigator.clipboard.writeText(data)
						this.notificationPush('success', 'Données exportées !')
					} catch (e) {
						this.notificationPush('error', `Impossible d'exporter les données dans le presse-papier.`)
					}
				} else if (type === 'file' && window.Blob && window.URL) {
					const data = JSON.stringify({
						invests: this.invests,
					})
					const blob = new Blob([data], {
						type: 'application/json;charset=utf-8',
					})
					e.target.setAttribute('href', URL.createObjectURL(blob))
					e.target.setAttribute('download', 'crypto-assets-' + Date.now() + '.json')
				} else if (type === 'synckey') {
					const data = this.syncKey
					try {
						navigator.clipboard.writeText(data)
						this.notificationPush('success', 'La clé de synchronisation a été copiée !')
					} catch (e) {
						this.notificationPush('error', 'Impossible de copier la clé de synchronisation.')
					}
				}
			},
			importDataFromJSON(data) {
				let valid = false
				try {
					const saveData = JSON.parse(data)
					if (saveData.invests && Array.isArray(saveData.invests)) {
						this.invests.splice(0)
						for (const invest of saveData.invests) {
							this.invests.push(invest)
						}
						valid = true
						this.saveInvests()
					}
				} catch (err) {
					console.error(err)
				}
				if (valid) {						
					this.notificationPush('success', 'Données importées !')
				} else {
					this.notificationPush('error', 'Données invalide dans le presse-papier.')
				}
			},
			async importData(e, type) {
				if (type === 'clipboard') {
					const data = await navigator.clipboard.readText()
					this.importDataFromJSON(data)
				} else if (type === 'file') {
					if (
						(event.target.files && event.target.files.length) ||
						(event.dataTransfer && event.dataTransfer.files && event.dataTransfer.files)
						) {
						const file = event.target.files ? event.target.files[0] : event.dataTransfer.files[0]
						const reader = new FileReader()
						reader.addEventListener('load', (event) => {
							const data = event.target.result
							this.importDataFromJSON(data)
						})
						reader.readAsText(file)
					} else if (event.target !== this.$refs.file) {
						this.$refs.file.click()
					} else {
						this.$refs.file.value = ''
					}
				} else if (type === 'synckey') {
					const data = await navigator.clipboard.readText()
					if (!/[A-Z]{24}/i.test(data)) {
						this.notificationPush('error', 'Clé de synchronisation non valide')
					} else {
						// TODO: Faire une vérification client à client
						this.syncKey = data
					}
				}
			},
			invest(invest = {}) {
				if (!invest.symbol) throw new Error('You must precise a symbol')
				if (!invest.value) throw new Error('You must precise a value')
				this.invests.push(invest)
				this.saveInvests()
			},
			revertInvest() {
				this.invests.pop()
				this.saveInvests()
			},
			clearInvest(symbol) {
				let founded = true
				while (founded) {
					const index = this.invests.findIndex(o => o.symbol === symbol)
					if (index === -1) founded = false
					else this.invests.splice(index, 1)
				}
				this.saveInvests()
			},
			getName(invest) {
				return this.symbols[invest.symbol] ? (this.symbols[invest.symbol].name || invest.symbol ) : invest.symbol
			},
			getValueInCurrency(invest) {
				if (!this.quotes[invest.symbol]) return ''
				return this.quotes[invest.symbol].value * invest.value
			},
			getProfit(invest) {
				if (!this.quotes[invest.symbol]) return ''
				return (this.quotes[invest.symbol].value * invest.value) - invest.amount
			},
			getProfitPercent(invest) {
				if (!this.quotes[invest.symbol] || invest.amount === 0) return 0
				return this.getProfit(invest) / invest.amount
			},
			getQuoteLastUpdateDate(invest) {
				const dt = new Date(this.quotes[invest.symbol] ? this.quotes[invest.symbol].updatedAt : null)
				return dt.toLocaleDateString() + ' à ' + dt.toLocaleTimeString()
			},
			getQuoteValue(invest) {
				const value = this.quotes[invest.symbol] ? this.quotes[invest.symbol].value : 0
				return value < 100 ? Number(value).toFixed(5) : Number(value).toFixed(2)
			},
			saveInvests() {
				window.localStorage.setItem('invests', JSON.stringify(this.invests))
			},
			saveQuotes() {
				window.localStorage.setItem('quotes', JSON.stringify(this.quotes))
			},
			async updateQuotes() {
				for (const invest of this.allInvestsBySymbol) {
					try {
						const quoteData = await axios.get(`/data/quotes/${invest.symbol}.json`, { params: { _t: Date.now() }}).then(response => response.data)
						if (!this.quotes[invest.symbol]) {
							this.quotes[invest.symbol] = quoteData
						} else {
							this.quotes[invest.symbol].value = quoteData.value
							this.quotes[invest.symbol].updatedAt = quoteData.updatedAt
						}
					} catch(err) {
						console.error(err)
					}
				}
				this.saveQuotes()
			},
			intervalUpdateQuotes() {
				clearTimeout(this.timeoutRefreshQuotes)
				this.timeoutRefreshQuotes = setTimeout(async() => {
					this.timeoutRefreshQuotes = -1
					await this.updateQuotes()
					this.intervalUpdateQuotes()
				}, 60000)
			},
			peerID(subid) {
				return 'stitchuuuu_crypto-assets_' + this.syncKey + '-' + subid
			},
			peerCreateClient() {
				const tryReconnect = () => this.peerClientReconnect()
				const peerClientInfo = this.peerClientInfo
				peerClientInfo.connecting = true
				peerClient = new Peer(this.peerID(this.peerSubclientID))
				peerClient.on('error', (err) => {
					if (err.type === 'unavailable-id') {
						this.peerSubclientID++
						peerClient.unavailableID = true
						this.peerCreateClient()
					}
				})
				peerClient.on('open', (id) => {
					peerClientInfo.connecting = false
					peerClientInfo.connected = true
					peerClientInfo.intervalSearchKind = setInterval(() => this.peerSearchSameKind(), 30000)
					this.peerSearchSameKind()
				})
				peerClient.on('disconnect', function(err) {
					peerClientInfo.connecting = false
					peerClientInfo.connected = false
					clearInterval(peerClientInfo.intervalSearchKind)
					peerClientInfo.intervalSearchKind = -1
					peerOtherClients = {}
					if (this.unavailableID) return
					peerClientInfo.timeoutReconnect = setTimeout(tryReconnect, 5000)
				})
				peerClient.on('server-error', () => {
					peerClientInfo.timeoutReconnect = setTimeout(tryReconnect, 5000)
				})
				peerClient.on('connection', (conn) => {
					console.log('connected with (in)', conn.peer)
					peerOtherClients[conn.peer] = conn
					// this.peerInitConnection(conn)
				})
			},
			peerClientReconnect() {
				this.peerStatusInfo.connecting = true
				this.peerClientInfo.timeoutReconnect = -1
				try {
					peerClient && peerClient.reconnect()
				} catch (err) {
					peerClient = this.peerCreateClient()
					console.error(err)
				}
			},
			peerInitConnection(conn) {
				conn.on('data', (d) => {
					console.log(d)
				})
			},
			peerSearchSameKind() {
				const allIds = []
				for (let i = 1; i < 64; i++) {
					if (i === this.peerSubclientID) continue
					const id = this.peerID(i)
					if (peerOtherClients[id]) continue
					const connection = peerClient.connect(this.peerID(i))
					peerOtherClients[id] = connection
					connection.on('error', (err) => {
						console.error('disconnected (error):', id)
						delete peerOtherClients[id]
					})
					connection.on('open', () => {
						console.log('connected with (out)', id)
						peerOtherClients[id] = connection
						// this.peerInitConnection(connection)
					})
					connection.on('error', (err) => {
						console.error('disconnected (error):', id)
						delete peerOtherClients[id]
					})
					connection.on('close', (err) => {
						console.error('disconnected (close):', id)
						delete peerOtherClients[id]
					})
					setTimeout(() => {
						if (!connection.open) {
							connection.close()
							delete peerOtherClients[id]
						}
					}, 2000)
				}
			},
		},
		watch: {
			syncKey(val) {
				window.localStorage.setItem('syncKey', val)
				if (val) {
					if (peerClient) {
						peerClient.disconnect()
					}
					this.peerCreateClient()
				}
			},
		},
		beforeUnmount() {
		},
		mounted() {
			window.addEventListener('beforeunload', () => {
				for (const conn of Object.values(peerOtherClients)) {
					console.log('Closing', conn.peer)
					conn.close()
				}
			})
			app = this
			const promises = []
			const lastQuotes = window.localStorage.getItem('quotes')
			const cryptoList = window.localStorage.getItem('symbols')
			this.syncKey = window.localStorage.getItem('syncKey') || null
			if (lastQuotes) {
				const data = JSON.parse(lastQuotes)
				for (const symbol of Object.keys(data)) {
					this.quotes[symbol] = data[symbol]
				}
				this.$nextTick(() => this.updateQuotes())
			} else {
				axios.get('/data/quotes/__all.json').then(response => response.data).then(data => data.data).then(list => {
					for (const q of list) {
						this.quotes[q.symbol] = q
					}
					window.localStorage.setItem('quotes', JSON.stringify(this.quotes))
				})
			}
			if (cryptoList) {
				const data = JSON.parse(cryptoList)
				for (const symbol of Object.keys(data)) {
					this.symbols[symbol] = data[symbol]
				}
			} else {
				axios.get('/data/crypto-list.json').then(response => response.data).then(data => data.data).then(list => {
					for (const q of list) {
						this.symbols[q.symbol] = q
					}
					window.localStorage.setItem('symbols', JSON.stringify(this.symbols))
				})
			}

			const invests = window.localStorage.getItem('invests')
			if (invests) {
				const data = JSON.parse(invests)
				for (const o of data) this.invests.push(o)
			}
			this.intervalUpdateQuotes()
		}
	}).mount('#app')
	</script>
</html>
